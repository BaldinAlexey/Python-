Задание 1: Таск-трекер в консоли

 Требования к реализации:
 1. Реализуйте класс Task
 для представления одной задачи (атрибуты: описание,
 статус выполнения, категория).
 2. Реализуйте класс TaskTracker , который будет хранить коллекцию задач и
 управлять ими.
 3. Данные должны сохраняться в JSON-файл при завершении программы и
 загружаться из него при запуске (используйте модуль 
json ).
 4. Реализуйте функционал:
 Добавление новой задачи с произвольным описанием и категорией.
 Отметка задачи как выполненной.
 Вывод списка всех задач.
 (Бонус) Поиск по задачам и вывод всех задач в указанной категории.
 Пример интерфейса:- [x] Задание выполнено #pstu- [ ] Еще задача #work- [ ] И еще задача #pstu

 Задание 2: Трекер бюджета в консоли
 Требования к реализации:
1. Реализуйте класс Transaction
 для представления одной финансовой операции
 (атрибуты: описание, сумма, тип [доход/расход], категория).
 2. Реализуйте класс BudgetTracker , который будет хранить историю операций и
 баланс.
 3. Данные должны сохраняться в JSON-файл и загружаться из него.
 4. Реализуйте функционал:
 Добавление новой операции с указанием суммы и категории.
 Расчет и отображение текущего баланса.
 (Бонус) Установка и проверка месячных лимитов для категорий расходов.

 Задание 3: Очередь и стек
 Требования к реализации:
 1. Реализуйте класс Queue
 (First In, First Out, FIFO) со следующими методами:
 enqueue(item)
 — добавление элемента в конец очереди.
 dequeue()
 — удаление и возврат элемента из начала очереди.
 peek()
 — просмотр первого элемента без его удаления.
 2. Реализуйте класс Stack
 (Last In, First Out, LIFO) со следующими методами:
 push(item)
 — добавление элемента на вершину стека.
 pop()
 — удаление и возврат элемента с вершины стека.
 peek()
 — просмотр верхнего элемента без его удаления.

 Задание 4: Модель шестизвенного манипулятора
 Требования к реализации:
 1. Создайте иерархию классов, описывающих разные виды сервоприводов, с
 минимум 3 уровнями (например, 
Двигатель -> ВращательныйДвигатель -> СинхронныйСервопривод ).
 2. Базовый класс должен определять общие атрибуты (например, 
угол_поворота ,скорость_вращения , ускорение ), а классы-потомки — добавлять специфичные.
 3. Реализуйте строковое представление классов с помощью методов 
__str__()
 и
 __repr__() 
.
 4. Перегрузите операторы сравнения (магические методы 
__eq__ , __lt__ и др.),
 чтобы позволить сравнивать экземпляры классов по одному из параметров
 (например, по мощности).
 5. Реализуйте упрощенную модель шестизвенного манипулятора, состоящего из
 нескольких сервоприводов.
 6. Реализуйте функцию перемещения манипулятора в пространстве через перегрузку
 арифметических операторов (например, 
__add__
 для сложения с вектором
 перемещения).

Задание 5: Иерархия классов с абстрактными методами
 Требования к реализации:
 1. Используя модуль abc , создайте абстрактный базовый класс 
Vehicle с абстрактными методами get_max_speed
 (максимальная скорость) и
 get_vehicle_type
 (тип транспортного средства).
 2. Создайте абстрактный подкласс RoadVehicle , который добавляет абстрактный метод 
get_engine_type .
 3. Создайте конкретные классы Car и Bicycle , реализующие все унаследованные
 абстрактные методы. Для Car тип двигателя может быть "бензиновый" или
 "электрический", а для Bicycle — "мускульная сила".
 Пример:
 car = Car("седан", "электрический")
 print(car.get_vehicle_type()) # Должно вывести: "Автомобиль"
 print(car.get_engine_type()) # Должно вывести: "электрический"

 Задание 6: Метапрограммирование
 Требования к реализации:
 1. Создайте базовый класс Plugin , в котором переопределен метод
 __init_subclass__ . При создании нового класса-потомка он должен
 автоматически добавляться в реестр плагинов (например, в словарь
 PluginRegistry ).
 2. Каждый плагин должен иметь уникальный атрибут name .
 3. Реализуйте метод execute
 в базовом классе, который выбрасывает исключениеNotImplementedError .
 4. Создайте 2-3 конкретных плагина (например, UpperCasePlugin , ReversePlugin ),которые реализуют метод execute
 (например, преобразуют строку).
 Пример:
 print(PluginRegistry) # Должно вывести: {'upper': <class
 '__main__.UpperCasePlugin'>, 'reverse': <class '__main__.ReversePlugin'>}
 plugin = PluginRegistry["upper"]()
 print(plugin.execute("hello")) # Должно вывести: "HELLO
